$date
	Tue Jun 18 11:17:50 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module testbench $end
$var wire 10 ! Raddr [9:0] $end
$var wire 1 " Rden $end
$var wire 10 # Waddr [9:0] $end
$var wire 32 $ Wdata [31:0] $end
$var wire 1 % Wren $end
$var wire 4 & Wstrb [3:0] $end
$var wire 1 ' mips_mem_rd $end
$var wire 32 ( mips_mem_rdata [31:0] $end
$var wire 4 ) mips_mem_wstrb [3:0] $end
$var wire 32 * mips_mem_wdata [31:0] $end
$var wire 32 + mips_mem_addr [31:0] $end
$var wire 32 , Rdata [31:0] $end
$var wire 32 - PC [31:0] $end
$var wire 1 . MemWrite $end
$var wire 1 / MemRead $end
$var wire 32 0 Instruction [31:0] $end
$var reg 1 1 mem_read_ref $end
$var reg 4 2 mem_wstrb_ref [3:0] $end
$var reg 1 3 mips_cpu_clk $end
$var reg 1 4 mips_cpu_reset $end
$var integer 32 5 PC_ref [31:0] $end
$var integer 32 6 mem_addr_ref [31:0] $end
$var integer 32 7 mem_bit_cmp_ref [31:0] $end
$var integer 32 8 mem_wdata_ref [31:0] $end
$var integer 32 9 new_PC_ref [31:0] $end
$var integer 32 : ret [31:0] $end
$var integer 32 ; rf_bit_cmp_ref [31:0] $end
$var integer 32 < rf_waddr_ref [31:0] $end
$var integer 32 = rf_wdata_ref [31:0] $end
$var integer 32 > trace_file [31:0] $end
$var integer 32 ? type [31:0] $end
$scope module u_ideal_mem $end
$var wire 10 @ Raddr1 [9:0] $end
$var wire 10 A Raddr2 [9:0] $end
$var wire 32 B Rdata1 [31:0] $end
$var wire 32 C Rdata2 [31:0] $end
$var wire 1 D Rden1 $end
$var wire 1 " Rden2 $end
$var wire 10 E Waddr [9:0] $end
$var wire 32 F Wdata [31:0] $end
$var wire 1 % Wren $end
$var wire 4 G Wstrb [3:0] $end
$var wire 1 3 clk $end
$var wire 8 H byte_3 [7:0] $end
$var wire 8 I byte_2 [7:0] $end
$var wire 8 J byte_1 [7:0] $end
$var wire 8 K byte_0 [7:0] $end
$upscope $end
$scope module u_mips_cpu $end
$var wire 32 L Instruction [31:0] $end
$var wire 32 M PCJR [31:0] $end
$var wire 5 N RF_raddr1 [4:0] $end
$var wire 5 O RF_waddr [4:0] $end
$var wire 32 P RF_wdata [31:0] $end
$var wire 32 Q Read_data [31:0] $end
$var wire 1 3 clk $end
$var wire 1 R jaljalr $end
$var wire 1 S jrra $end
$var wire 32 T nextPC [31:0] $end
$var wire 1 4 rst $end
$var wire 5 U sa [4:0] $end
$var wire 5 V rt [4:0] $end
$var wire 5 W rs [4:0] $end
$var wire 5 X rd [4:0] $end
$var wire 6 Y op [5:0] $end
$var wire 6 Z func [5:0] $end
$var wire 4 [ Write_strb [3:0] $end
$var wire 32 \ Write_data [31:0] $end
$var wire 32 ] Signimm [31:0] $end
$var wire 1 ^ RegDst $end
$var wire 1 _ RF_wen $end
$var wire 32 ` RF_rdata2 [31:0] $end
$var wire 32 a RF_rdata1 [31:0] $end
$var wire 5 b RF_raddr2 [4:0] $end
$var wire 32 c PCadd [31:0] $end
$var wire 2 d PCSrc [1:0] $end
$var wire 32 e PCJA [31:0] $end
$var wire 32 f PCBranch [31:0] $end
$var wire 2 g MemtoReg [1:0] $end
$var wire 1 . MemWrite $end
$var wire 1 / MemRead $end
$var wire 32 h Data_out [31:0] $end
$var wire 32 i Address_out [31:0] $end
$var wire 32 j Address [31:0] $end
$var wire 1 k ALUsa $end
$var wire 1 l ALU_Zero $end
$var wire 1 m ALU_Signal $end
$var wire 32 n ALU_Result [31:0] $end
$var wire 1 o ALU_Overflow $end
$var wire 1 p ALU_CarryOut $end
$var wire 32 q ALU_B [31:0] $end
$var wire 4 r ALU_ALUop [3:0] $end
$var wire 32 s ALU_A [31:0] $end
$var wire 1 t ALUSrc $end
$var reg 32 u PC [31:0] $end
$var reg 32 v sp [31:0] $end
$scope module ALU $end
$var wire 32 w A [31:0] $end
$var wire 32 x B [31:0] $end
$var wire 1 y Overflow_Add $end
$var wire 1 z Overflow_Sub $end
$var wire 32 { Result [31:0] $end
$var wire 32 | Result_And [31:0] $end
$var wire 32 } Result_Mov [31:0] $end
$var wire 32 ~ Result_Nor [31:0] $end
$var wire 32 !" Result_Or [31:0] $end
$var wire 32 "" Result_Slt [31:0] $end
$var wire 32 #" Result_Xor [31:0] $end
$var wire 1 l Zero $end
$var wire 1 m Signal $end
$var wire 32 $" Result_Sub [31:0] $end
$var wire 32 %" Result_Srl [31:0] $end
$var wire 32 &" Result_Sra [31:0] $end
$var wire 32 '" Result_Sltu [31:0] $end
$var wire 32 (" Result_Sll [31:0] $end
$var wire 33 )" Result_S [32:0] $end
$var wire 32 *" Result_Add [31:0] $end
$var wire 1 o Overflow $end
$var wire 1 p CarryOut $end
$var wire 4 +" ALUop [3:0] $end
$upscope $end
$scope module Controller $end
$var wire 1 ," ALU_And $end
$var wire 1 -" ALU_Bgez $end
$var wire 1 ." ALU_Movn $end
$var wire 1 /" ALU_Movz $end
$var wire 1 0" ALU_Nor $end
$var wire 1 1" ALU_Or $end
$var wire 1 2" ALU_Sll $end
$var wire 1 3" ALU_Slt $end
$var wire 1 4" ALU_Sltu $end
$var wire 1 5" ALU_Sra $end
$var wire 1 6" ALU_Srl $end
$var wire 1 7" ALU_Sub $end
$var wire 1 8" ALU_Xor $end
$var wire 4 9" ALUop [3:0] $end
$var wire 1 k ALUsa $end
$var wire 1 :" Branch $end
$var wire 1 ;" Branch1 $end
$var wire 1 <" Branch2 $end
$var wire 1 =" Branch3 $end
$var wire 1 >" BranchSignal $end
$var wire 1 ?" I_type $end
$var wire 32 @" Instruction [31:0] $end
$var wire 1 A" J_type $end
$var wire 1 / MemRead $end
$var wire 1 . MemWrite $end
$var wire 1 _ RegWrite $end
$var wire 1 m Signal $end
$var wire 1 l Zero $end
$var wire 1 B" jaljalr $end
$var wire 1 C" jrra $end
$var wire 6 D" op [5:0] $end
$var wire 6 E" func [5:0] $end
$var wire 1 ^ RegDst $end
$var wire 1 F" R_type $end
$var wire 2 G" PCSrc [1:0] $end
$var wire 2 H" MemtoReg [1:0] $end
$var wire 1 t ALUSrc $end
$upscope $end
$scope module Dataconverter $end
$var wire 32 I" Address_in [31:0] $end
$var wire 32 J" Data_in [31:0] $end
$var wire 32 K" Data_lb [31:0] $end
$var wire 32 L" Data_lbu [31:0] $end
$var wire 32 M" Data_lh [31:0] $end
$var wire 32 N" Data_lhu [31:0] $end
$var wire 32 O" Data_load [31:0] $end
$var wire 32 P" Data_lwl [31:0] $end
$var wire 32 Q" Data_lwr [31:0] $end
$var wire 32 R" Data_sb [31:0] $end
$var wire 32 S" Data_sh [31:0] $end
$var wire 32 T" Data_store [31:0] $end
$var wire 32 U" Data_swl [31:0] $end
$var wire 32 V" Data_swr [31:0] $end
$var wire 32 W" Instruction [31:0] $end
$var wire 4 X" Write_strb [3:0] $end
$var wire 4 Y" Write_strb_sb [3:0] $end
$var wire 4 Z" Write_strb_sh [3:0] $end
$var wire 4 [" Write_strb_swl [3:0] $end
$var wire 4 \" Write_strb_swr [3:0] $end
$var wire 6 ]" op [5:0] $end
$var wire 2 ^" n [1:0] $end
$var wire 32 _" Data_rf2 [31:0] $end
$var wire 32 `" Data_out [31:0] $end
$var wire 32 a" Address_out [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 3 clk $end
$var wire 5 b" raddr1 [4:0] $end
$var wire 5 c" raddr2 [4:0] $end
$var wire 1 4 rst $end
$var wire 5 d" waddr [4:0] $end
$var wire 32 e" wdata [31:0] $end
$var wire 1 _ wen $end
$var wire 32 f" rdata2 [31:0] $end
$var wire 32 g" rdata1 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 g"
bx f"
b100000000000000 e"
b11101 d"
b11101 c"
b0 b"
b100000000000000 a"
b0xxxxxxxxxxxxxxxx `"
bx _"
b0 ^"
b1001 ]"
b1111 \"
b1 ["
b11 Z"
b1 Y"
b11 X"
b100100000111010100000000000000 W"
bx V"
bx U"
b0xxxxxxxxxxxxxxxx T"
b0xxxxxxxxxxxxxxxx S"
b0xxxxxxxx R"
b0 Q"
b0xxxxxxxxxxxxxxxxxxxxxxxx P"
b0 O"
b0 N"
b0 M"
b0 L"
b0 K"
b0 J"
b100000000000000 I"
b0 H"
b0 G"
0F"
b0 E"
b1001 D"
0C"
0B"
0A"
b100100000111010100000000000000 @"
1?"
0>"
0="
0<"
0;"
0:"
b0 9"
08"
07"
06"
05"
04"
03"
02"
01"
00"
0/"
0."
0-"
0,"
b0 +"
b100000000000000 *"
b100000000000000 )"
b100000000000000 ("
b0 '"
b100000000000000 &"
b100000000000000 %"
b100000000000000 $"
b100000000000000 #"
b0 ""
b100000000000000 !"
b11111111111111111011111111111111 ~
b0 }
b0 |
b100000000000000 {
0z
0y
b100000000000000 x
b0 w
b10000000000000000000100000000000 v
b0 u
1t
b0 s
b0 r
b100000000000000 q
0p
0o
b100000000000000 n
0m
0l
0k
b100000000000000 j
b100000000000000 i
b0xxxxxxxxxxxxxxxx h
b0 g
b10000000000000100 f
b11101010000000000000000 e
b0 d
b100 c
b11101 b
b0 a
bx `
1_
0^
b100000000000000 ]
b0xxxxxxxxxxxxxxxx \
b11 [
b0 Z
b1001 Y
b1000 X
b0 W
b11101 V
b0 U
b100 T
0S
0R
b0 Q
b100000000000000 P
b11101 O
b0 N
b0 M
b100100000111010100000000000000 L
b0 K
b1000000 J
b11101 I
b100100 H
b0 G
b0 F
b0 E
1D
b0 C
b100100000111010100000000000000 B
b0 A
b0 @
bx ?
b10000000000000000000000000000011 >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
14
03
bx 2
x1
b100100000111010100000000000000 0
0/
0.
b0 -
b0 ,
b100000000000000 +
b0xxxxxxxxxxxxxxxx *
b11 )
b0 (
0'
b0 &
0%
b0 $
b0 #
0"
b0 !
$end
#10
b100000000000000 *
b100000000000000 \
b100000000000000 h
b100000000000000 `"
b100000000000000 T"
b10000000000000000000000 U"
b0 R"
b100000000000000 P"
b100000000000000 S"
b100000000000000 V"
b100000000000000 `
b100000000000000 _"
b100000000000000 f"
13
#20
03
#30
b0 P
b0 e"
b0 +
b0 j
b0 i
b0 a"
b0 n
b0 {
b0 I"
b0 U"
b0 P"
b0 *
b0 \
b0 S"
b0 V"
b0 h
b0 `"
b11111111111111111111111111111111 ~
b0 *"
b0 $"
0t
b0 O"
b0 T"
b0 !"
b0 #"
b0 )"
1^
b1 )
b1 [
b1 X"
b0 ("
b0 %"
b0 &"
b0 q
b0 x
b0 O
b0 d"
b11 d
b11 G"
0_
b100 ]
b0 `
b0 _"
b0 f"
0?"
b10000 T
b0 b
b0 c"
1A"
b10000 e
b10 Y
b0 V
b0 X
b100 Z
b10 D"
b100 E"
b10 ]"
b1000000000000000000000000100 0
b1000000000000000000000000100 B
b1000000000000000000000000100 L
b1000000000000000000000000100 @"
b1000000000000000000000000100 W"
b1 @
b11000 f
b1000 c
b100 -
b100 u
01
b11111111111111111111111111111111 ;
b100000000000000 =
b11101 <
b0 5
b100 :
b1 ?
13
04
#40
03
#50
b0 J
b0 I
b0 H
b1111 )
b1111 [
b1111 X"
b11111 O
b11111 d"
b1000000000 #
b1000000000 E
b11000 K
b11000 P
b11000 e"
b10000000000000000000100000000000 +
b10000000000000000000100000000000 j
b1111 &
b1111 G
b11000 $
b11000 F
1_
b1100110 ]
b110011000 T
b11000 *
b11000 \
b10 g
b10 H"
1%
1.
1R
1B"
b110011000 e
b11 Y
b1 U
b100110 Z
b11 D"
b100110 E"
b11 ]"
b1100000000000000000001100110 0
b1100000000000000000001100110 B
b1100000000000000000001100110 L
b1100000000000000000001100110 @"
b1100000000000000000001100110 W"
b100 @
b110101100 f
b10100 c
b10000 -
b10000 u
b10000 9
b100 5
b1 :
b11 ?
13
#60
03
#70
b11111111101000 i
b11111111101000 a"
b11111111101000 n
b11111111101000 {
b11111111101000 I"
b100000000000000 h
b100000000000000 `"
b100000000000000 T"
1p
b1 '"
b10000000000000000000000 U"
b100000000000000 P"
b11101 O
b11101 d"
b11111111111111111011111111101000 #"
b100000000000000 S"
b100000000000000 V"
0="
b11101 I
b100100 H
1t
b10111 ~
0^
b11 )
b11 [
b11 X"
b100000000000000 |
b11111111111111111111111111101000 !"
b11111111101000 *"
b11111111101000 $"
b11111111111111111111111111101000 ("
b11111111111111111111111111101000 %"
b11111111111111111111111111101000 &"
b11111111111111111111111111101000 q
b11111111111111111111111111101000 x
0:"
b0 d
b0 G"
b0 &
b0 G
b11111111111111111111111111101000 ]
b110011100 T
b100000000000000 }
b100000000000000000011111111101000 )"
b100000000000000 s
b100000000000000 w
b100000000000000 `
b100000000000000 _"
b100000000000000 f"
1?"
b0 g
b0 H"
0%
0.
b0 K
b1000000 J
0R
b100000000000000 M
b100000000000000 a
b100000000000000 g"
b11101 b
b11101 c"
0A"
0B"
b1110111101111111111110100000 e
b1001 Y
b11101 N
b11101 b"
b11101 W
b11101 V
b11111 X
b11111 U
b101000 Z
b1001 D"
b101000 E"
b1001 ]"
b0 #
b0 E
b0 $
b0 F
b11111111101000 P
b11111111101000 e"
b100111101111011111111111101000 0
b100111101111011111111111101000 B
b100111101111011111111111101000 L
b100111101111011111111111101000 @"
b100111101111011111111111101000 W"
b100000000000000 *
b100000000000000 \
b1100110 @
b11111111101000 +
b11111111101000 j
b100111100 f
b110011100 c
b110011000 -
b110011000 u
b10000000000000000000100000000100 v
b10000 5
b100 ?
13
